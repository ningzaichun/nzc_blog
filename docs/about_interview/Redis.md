# Redis 面试篇

### 一、基础

#### 1、五大基本数据类型

五大基本数据类型：string、list、set、zset(sorted set)、hash。 

五大基本数据类型分别的应用场景：



#### 2、Redis 的特点？

1 因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过10 万次读写操作，是已知性能最快的 Key-Value 数据库。Redis 支持事务 、持久化

2、单线程操作，避免了频繁的上下文切换。 

3、采用了非阻塞 I/O 多路复用机制。I/O 多路复用就是只有单个线程，通过跟踪每个 I/O 流的状态，来管理多个 I/O 流。



#### 3、为什么使用 Redis？

- 解决应用服务器的CPU和内存压力；

- 减少IO的读操作，减轻IO的压力；

- 关系型数据库的扩展性不强，难以改变表结构；

Nosql数据库没有关联关系，数据结构简单，拓展表比较容易； 

Nosql读取速度快，对较大数据处理快；





#### 4、Redis 的持久化

**RDB 持久化**：该机制可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。 RDB，简而言之，就是在不同的时间点，将 redis 存储的数据生成快照并存储到磁盘等介质上

**AOF 持久化**：记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。AOF，则是换了一个角度来实现持久化，那就是将 redis 执行过的所有写指令记录下来，在下次 redis 重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了



AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。Redis 还可

以在后台对 AOF 文件 进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所的

实际大小 

**无持久化**：让数据只在服务器运行时存在。 

**持久化**：同时应用 AOF 和 RDB：当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的 数据集通常比 RDB 文件所保存的数据集更完整。

##### **RDB 的优缺点**： 

**1）优点**：RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据

集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次

RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以

随时将数据集还原到不同的版本。RDB 非常适用于灾难恢复（disaster recovery）：它只有一个

文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。

RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，

然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。RDB 在恢

复大数据集时的速度比 AOF 的恢复速度要快。 

**2）缺点**：如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许

你设置不同 的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为 RDB 文件需要

保存整个数据集的状态， 所 以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次

RDB 文件。 在这种情况下， 一旦发生故 障停机， 你就可能会丢失好几分钟的数据。每次保存

RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集

比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端；如果数据集非

常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 

##### AOF 的优缺点：

**1）优点**： 

1、使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync

策略，比如 无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。AOF 的默认策略

为每秒钟 fsync 一次，在这种 配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理

命令请求）。AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文

件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁

盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。 

2、Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 

文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创

建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停

机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切

换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。 



**缺点**： 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间 （latency）。



#### 5.1、缓存和数据库双写一致性问题 

一致性的问题很常见，因为加入了缓存之后，请求是先从 redis 中查询，如果redis 中存在数据就不会走数据库了，如果不能保证缓存跟数据库的一致性就会导致请求获取到的数据不是最新的数据。 

解决方案： 

1、编写删除缓存的接口，在更新数据库的同时，调用删除缓存的接口删除缓存中的数据。这么做会有耦合高以及调用接口失败的情况。

2、消息队列：ActiveMQ，消息通知。 



#### 5.2、Redis的双写一致性如何保证？

采用延时双删策略：
1、先淘汰缓存
​2、再写数据库
​3、休眠1秒，再次淘汰缓存 （这里可以异步，如果更深层次的考虑就是这一步失败的话，该如何，一般延时双删可以解决大部分情况）



可以看看这一篇 ：https://blog.csdn.net/m0_67698950/article/details/125103586



如果一定要强一致性的话，就尝试加锁 串行化吧，以性能换强一致性。

#### 6、缓存的并发竞争问题 

并发竞争，指的是同时有多个子系统去 set 同一个 key 值。 

解决方案： 

1、最简单的方式就是准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可 



#### 7、缓存雪崩：

**原因**：1）Redis挂掉了，请求全部走数据库。
2）缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。
**解决方案**：

- 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生
- 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中
- 使用互斥锁，但是该方案吞吐量明显下降了。 
- 允许的话，设置热点数据永远不过期
- 要保证redis的高可用，可以使用主从+哨兵或redis cluster，避免服务器不可用
- 使用redis的持久化RDB+AOF组合策略，防止缓存丢失并且可以快速恢复数据

#### 8、缓存击穿：

缓存中没有但数据库中有的数据，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力；

缓存穿透，即故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。 		

**解决方案**：
1）、设置热点数据不过期；
2）、第一时间去数据库获取数据填充到redis中，但是这个过程需要加锁，防止所有线程都去读取数据库，一旦有一个线程去数据库获取数据了，其他线程取锁失败后可设置一个合理睡眠时间之后再去尝试去redis中获取数据；

#### 9、缓存穿透：

即缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为 -1 的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大

**解决方案**：

1、接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；

2、从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓

存有效时间可以设置短点，设置太长会导致正常情况也没法使用。这样可以防止攻击用户反复用

同一个id暴力攻击；

3、引入**布隆过滤器**，过滤一些异常的请求。





#### 10、Redis过期数据的删除策略是什么？有哪些？

​	定时删除、惰性过期、定期过期

#### 11、Redis的数据淘汰策略是什么？有哪些？

​	1、volatile-lru：
​		从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
​	2、volatile-ttl：
​		从已设置过期时间的数据集中挑选将要过期的数据淘汰
​	3、volatile-random：
​		从已设置过期时间的数据集中任意选择数据淘汰
​	4、**allkeys-lru**：（最常用）
​		从数据集中挑选最近最少使用的数据淘汰
​	5、allkeys-random：
​		从数据集中任意选择数据淘汰
​	6、no-enviction（驱逐）：
​		禁止驱逐数据



#### 12、Redis 的分布式锁

Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫**Redlock**，此种方式比原先的单节点的方法更安全。

它可以保证以下特性： 

1>**安全特性**：互斥访问，即永远只有一个 client 能拿到锁 

2>**避免死锁**：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的client crash 了或者出现了网络分区 

3>**容错性**：只要大部分 Redis 节点存活就可以正常提供服务 



**分布式锁可重点看这篇文章，内容详细，深度够，思考足够**：https://mp.weixin.qq.com/s/s8xjm1ZCKIoTGT3DCVA4aw



#### 13、Redis 实现分布式锁 

Redis 为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis 的连接并不存在竞争关系 

Redis 中可以使用 **SETNX** 命令实现分布式锁。

当且仅当 key 不存在，将 key 的值设为 value。 

若给定的 key 已经存在，则SETNX不做任何动作 

SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。

返回值：设置成功，返回 1 。设置失败，返回 0 。

![image-20220605165814300](https://raw.githubusercontent.com/ningzaichun/nzc_img_store/main/img/202206051658229.png)

使用 SETNX 完成同步锁的流程及事项如下： 

使用 SETNX 命令获取锁，若返回 0（key 已存在，锁已存在）则获取失败，

反之获取成功 

为了防止获取锁后程序出现异常，导致其他线程/进程调用 SETNX 命令总是返回0 而进入死锁状态，需要为该 key 设置一个“合理”的过期时间 释放锁，使用 DEL 命令将锁数据删除



#### 14、如何正确使用Redis的分布式事务锁？（Zookeeper也可以实现分布式锁）

正确使用redis分布式事务锁需要保证两个原子性：
1、上锁和设置过期时间需要保证原子性；
​2、 判断锁ID是否为自己所有和解锁需要保证原子性









### 二、应用场景

#### 1、缓存

>  缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。 

**缓存—热数据**

>  热点数据（经常会被查询，但是不经常被修改或者删除的数据），首选是使用redis缓存，毕竟强大到冒泡的QPS和极强的稳定性不是所有类似工具都有的，而且相比于memcached还提供了丰富的数据类型可以使用，另外，内存中的数据也提供了AOF和RDB等持久化机制可以选择，要冷、热的还是忽冷忽热的都可选。 

结合具体应用需要注意一下：很多人用spring的AOP来构建redis缓存的自动生产和清除，过程可能如下：

>  select 数据库前查询redis，有的话使用redis数据，放弃select 数据库，没有的话，select 数据库，然后将数据插入redis； update或者delete数据库钱，查询redis是否存在该数据，存在的话先删除redis中数据，然后再update或者delete数据库中的数据； 

上面这种操作，如果并发量很小的情况下基本没问题，但是高并发的情况请注意下面场景：

>  为了update先删掉了redis中的该数据，这时候另一个线程执行查询，发现redis中没有，瞬间执行了查询SQL，并且插入到redis中一条数据，回到刚才那个update语句，这个悲催的线程压根不知道刚才那个该死的select线程犯了一个弥天大错！于是这个redis中的错误数据就永远的存在了下去，直到下一个update或者delete。



#### 2、排行榜

>  很多网站都有排行榜应用的，如淘宝的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。 

谁得分高谁排名往上。命令：ZADD（有续集，sorted set）



#### 3、计数器

>  什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。 

**计数器**

诸如统计点击数等应用。由于单线程，可以避免并发问题，保证不会出错，而且100%毫秒级性能；

命令：INCRBY



#### **4、分布式会话**

>  集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存[数据库管理](https://cloud.tencent.com/product/dbbrain?from=10680)。 



#### 5、分布式锁

>  在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。 

**分布式锁**

验证前端的重复请求【幂等性】（可以自由扩展类似情况），可以通过redis进行过滤：每次请求将request ip、参数、接口等hash作为key存储redis(幂等性请求)，设置多长时间有效期，然后下次请求过来的时候先在redis中检索有没有这个key，进而验证是不是一定时间内过来的重复提交秒杀系统，基于redis是单线程特征，防止出现数据库’爆破’全局增量ID生成，类似’秒杀’。



#### **6、 社交网络**

>  点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。 
>
> 

set 取数据交集、并集：
基于 redis set 的特性可以对共同好友进行很方便的查询 共同关注共同点赞等等



#### 7、最新列表

>  Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。 

**最新列表**

例如新闻列表页面最新的新闻列表，如果总数量很大的情况下，尽量不要使用select a from A limit 10这种low货，尝试redis的 LPUSH命令构建List，一个个顺序都塞进去就可以啦。不过万一内存清掉了咋办？也简单，查询不到存储key的话，用mysql查询并且初始化一个List到redis中就好了。





#### **8、消息系统**

>  [消息队列](https://cloud.tencent.com/product/cmq?from=10680)是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。

**消息队列**

相当于消息系统，ActiveMQ，RocketMQ等工具类似，如果对于数据一致性要求高的话还是用RocketMQ等专业系统。

由于redis把数据添加到队列是返回添加元素在队列的第几位，所以可以做判断用户是第几个访问这种业务；队列不仅可以把并发请求变成串行，并且还可以做队列或者栈使用。

#### 9、位操作（大数据处理）

用于数据量上亿的场景下，例如几亿用户系统的签到，去重登录次数统计，某用户是否在线状态等等。

想想一下腾讯10亿用户，要几个毫秒内查询到某个用户是否在线，你能怎么做？这里要用到位操作——使用setbit、getbit、bitcount命令。

原理是：

redis内构建一个足够长的数组，每个数组元素只能是0和1两个值，然后这个数组的下标index用来表示我们上面例子里面的用户id（必须是数字哈），那么很显然，这个几亿长的大数组就能通过下标和元素值（0和1）来构建一个记忆系统，上面我说的几个场景也就能够实现。用到的命令是：setbit、getbit、bitcount。

#### 10、适用场景：

数据高并发的读写；

海量数据的读写；

对扩展性要求高的数据。





### 三、常见的面试题

#### 项目搭建多级缓存的好处是什么？实现多级缓存的流程是什么？（加分项）

好处：
​		可以避免缓存雪崩（缓存失效，大量请求直达DB），提高系统的可用性
流程：
​		1、反向代理nginx将请求负载均衡到业务nginx集群
​		2、接着业务Nginx读取本地缓存（本地缓存可以使用Lua），如果本地缓存命中则直接返回，
​		  使用应用Nginx本地缓存可以提升整体的吞吐量，降低后端的压力，尤其应对热点问题非常有效
​		3、如果Nginx本地缓存没有命中，则会读取相应的分布式缓存（如Redis缓存，另外可以考虑使用主从架构来提升性能和吞吐量），
​		  如果分布式缓存命中则直接返回相应的数据（并会写到Nginx本地缓存）
​		4、如果分布式缓存也没有命中，则会回源到Tomcat集群，在回源到Tomcat集群时也可以使用轮询和一致性哈希作为负载均衡算法
​		5、在Tomcat中，首先读取本地堆缓存，如果有则直接返回（并会写到Redis集群）
​		6、如果所有的缓存都没有命中只能查询DB或相关服务获取相关数据并返回
​		7、返回的数据异步写到Redis

